import { supabase } from "@/integrations/supabase/client";

export class AudioRecorder {
  private stream: MediaStream | null = null;
  private audioContext: AudioContext | null = null;
  private processor: ScriptProcessorNode | null = null;
  private source: MediaStreamAudioSourceNode | null = null;

  constructor(private onAudioData: (audioData: Float32Array) => void) {}

  async start() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          sampleRate: 24000,
          channelCount: 1,
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      });

      this.audioContext = new AudioContext({
        sampleRate: 24000,
      });

      this.source = this.audioContext.createMediaStreamSource(this.stream);
      this.processor = this.audioContext.createScriptProcessor(4096, 1, 1);

      this.processor.onaudioprocess = (e) => {
        const inputData = e.inputBuffer.getChannelData(0);
        this.onAudioData(new Float32Array(inputData));
      };

      this.source.connect(this.processor);
      this.processor.connect(this.audioContext.destination);
    } catch (error) {
      console.error('Error accessing microphone:', error);
      throw error;
    }
  }

  stop() {
    if (this.source) {
      this.source.disconnect();
      this.source = null;
    }
    if (this.processor) {
      this.processor.disconnect();
      this.processor = null;
    }
    if (this.stream) {
      this.stream.getTracks().forEach(track => track.stop());
      this.stream = null;
    }
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }
  }
}

export interface RealtimeMessage {
  type: string;
  [key: string]: unknown;
}

export class RealtimeChat {
  private pc: RTCPeerConnection | null = null;
  private dc: RTCDataChannel | null = null;
  private audioEl: HTMLAudioElement;
  private conversationId: string | null = null;

  constructor(private onMessage: (message: RealtimeMessage) => void) {
    this.audioEl = document.createElement("audio");
    this.audioEl.autoplay = true;
  }

  async init() {
    try {
      // Create conversation record
      const { data: conv, error: convErr } = await supabase
        .from('conversations')
        .insert({ status: 'active' })
        .select('id')
        .single();

      if (convErr) throw convErr;
      this.conversationId = conv.id;
      console.log('Conversation created:', this.conversationId);

      // Get ephemeral token
      const { data: tokenData, error: tokenError } = await supabase.functions.invoke("realtime-session");

      if (tokenError || !tokenData?.client_secret?.value) {
        console.error("Token error:", tokenError, tokenData);
        throw new Error("Failed to get ephemeral token");
      }

      const EPHEMERAL_KEY = tokenData.client_secret.value;
      console.log("Got ephemeral token");

      // Create peer connection
      this.pc = new RTCPeerConnection();

      // Set up remote audio
      this.pc.ontrack = e => {
        console.log("Received audio track");
        this.audioEl.srcObject = e.streams[0];
      };

      // Add local audio track
      const ms = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.pc.addTrack(ms.getTracks()[0]);

      // Set up data channel
      this.dc = this.pc.createDataChannel("oai-events");

      this.dc.addEventListener("message", async (e) => {
        const event = JSON.parse(e.data);
        console.log("Received event:", event.type);
        this.onMessage(event);

        // Handle session.created - send configuration
        if (event.type === 'session.created') {
          const { data: config } = await supabase
            .from('agent_config')
            .select('*')
            .limit(1)
            .maybeSingle();

          const instructions = config 
            ? `You are a receptionist for ${config.restaurant_name}.
Hours: ${config.restaurant_hours}
Menu: ${config.menu}
${config.instructions}

When a customer wants to make a reservation, collect:
1. Their name
2. Their email address
3. Date (YYYY-MM-DD format)
4. Time (HH:MM format)
5. Number of guests

Then use the create_reservation function.`
            : "You are a helpful restaurant receptionist.";

          this.dc!.send(JSON.stringify({
            type: 'session.update',
            session: {
              modalities: ['text', 'audio'],
              instructions: instructions,
              voice: 'alloy',
              input_audio_format: 'pcm16',
              output_audio_format: 'pcm16',
              input_audio_transcription: { model: 'whisper-1' },
              turn_detection: {
                type: 'server_vad',
                threshold: 0.5,
                prefix_padding_ms: 300,
                silence_duration_ms: 1000
              },
              tools: [
                {
                  type: 'function',
                  name: 'create_reservation',
                  description: 'Create a restaurant reservation',
                  parameters: {
                    type: 'object',
                    properties: {
                      name: { type: 'string' },
                      email: { type: 'string', description: 'Customer email address' },
                      date: { type: 'string', description: 'YYYY-MM-DD' },
                      time: { type: 'string', description: 'HH:MM' },
                      guests: { type: 'number' }
                    },
                    required: ['name', 'email', 'date', 'time', 'guests']
                  }
                }
              ],
              tool_choice: 'auto',
              temperature: 0.8
            }
          }));
        }

        // Handle function calls
        if (event.type === 'response.function_call_arguments.done') {
          const args = JSON.parse(event.arguments);
          console.log("Creating reservation:", args);

          // Save reservation
          const { data: resv, error: resvErr } = await supabase
            .from('reservations')
            .insert({
              conversation_id: this.conversationId,
              name: args.name,
              email: args.email,
              date: args.date,
              time: args.time,
              guests: args.guests,
              status: 'confirmed'
            })
            .select()
            .single();

          if (!resvErr && resv) {
            console.log("Reservation created:", resv.id);
            
            // Send confirmation email
            const { data: config } = await supabase
              .from('agent_config')
              .select('restaurant_name')
              .limit(1)
              .maybeSingle();

            await supabase.functions.invoke('send-reservation-confirmation', {
              body: {
                name: args.name,
                email: args.email,
                date: args.date,
                time: args.time,
                guests: args.guests,
                restaurantName: config?.restaurant_name || 'Restaurant'
              }
            });
          }

          // Send function output
          this.dc!.send(JSON.stringify({
            type: 'conversation.item.create',
            item: {
              type: 'function_call_output',
              call_id: event.call_id,
              output: JSON.stringify({ 
                success: true, 
                message: `Reservation confirmed for ${args.name} on ${args.date} at ${args.time} for ${args.guests} guests.`
              })
            }
          }));
          this.dc!.send(JSON.stringify({ type: 'response.create' }));
        }
      });

      // Create and set local description
      const offer = await this.pc.createOffer();
      await this.pc.setLocalDescription(offer);

      // Connect to OpenAI
      const baseUrl = "https://api.openai.com/v1/realtime";
      const model = "gpt-4o-realtime-preview-2024-12-17";
      const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {
        method: "POST",
        body: offer.sdp,
        headers: {
          Authorization: `Bearer ${EPHEMERAL_KEY}`,
          "Content-Type": "application/sdp"
        },
      });

      if (!sdpResponse.ok) {
        throw new Error(`Failed to connect to OpenAI: ${sdpResponse.status}`);
      }

      const answer: RTCSessionDescriptionInit = {
        type: "answer",
        sdp: await sdpResponse.text(),
      };

      await this.pc.setRemoteDescription(answer);
      console.log("WebRTC connection established");

    } catch (error) {
      console.error("Error initializing chat:", error);
      throw error;
    }
  }

  async sendText(text: string) {
    if (!this.dc || this.dc.readyState !== 'open') {
      throw new Error('Data channel not ready');
    }

    this.dc.send(JSON.stringify({
      type: 'conversation.item.create',
      item: {
        type: 'message',
        role: 'user',
        content: [{ type: 'input_text', text }]
      }
    }));
    this.dc.send(JSON.stringify({ type: 'response.create' }));
  }

  async disconnect() {
    // Update conversation status
    if (this.conversationId) {
      await supabase
        .from('conversations')
        .update({ 
          status: 'completed', 
          ended_at: new Date().toISOString() 
        })
        .eq('id', this.conversationId);
    }

    this.dc?.close();
    this.pc?.close();
  }
}
